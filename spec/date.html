<!doctype html>
<meta charset="utf8">

<emu-clause id=sec-temporal-date>
  <h1>Temporal.Date Objects</h1>
  <p>A Temporal.Date object is an immutable Object that contains Number values corresponding to a particular year, month,
    and day.</p>

  <emu-clause id=sec-temporal-date-constructor>
    <h1>The Temporal.Date Constructor</h1>
    <p>The Temporal.Date constructor is the %Temporal.Date% intrinsic object. When called as a constructor, it creates and
      initializes a new Temporal.Date object.</p>
    <p>
      The Temporal.Date constructor is designed to be subclassable.
      It may be used as the value of an extends clause of a class definition.
      Subclass constructors that intend to inherit the specified Date behaviour must include a super call to the %Temporal.Date% constructor to create and initialize subclass instances with the necessary internal slots.</p>

    <emu-clause id=sec-temporal-date-constructor-alg>
      <h1>Temporal.Date ( _year_, _month_, _day_, _disambiguation_ )</h1>
      <p>When the Temporal.Date function is called, the following steps are taken:</p>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _y_ be ? ToInteger(_year_).
        1. Let _m_ be ? ToInteger(_month_).
        1. Let _d_ be ? ToInteger(_day_).
        1. Let _disambiguation_ be ? ToString(_disambiguation_).
        1. Let _result_ be ? RegulateDate(_y_, _m_, _d_, _disambiguation_).
        1. Return ? CreateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id=sec-properties-of-the-temporal-date-constructor>
    <h1>Properties of the Temporal.Date Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.Date constructor is the intrinsic object
      %FunctionPrototype%.</p>
    <p>The Temporal.Date constructor has the following properties:</p>

    <emu-clause id=sec-temporal-date-prototype>
      <h1>Temporal.Date.prototype</h1>
      <p>The initial value of Temporal.Date.prototype is %Temporal.Date.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.fromString ( _isostring_ )</h1>
      <p>
        The `fromString` method takes one argument _isostring_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _isostring_ be ? ToString(_isostring_).
        1. Return ? DateFromString(_isostring_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.from ( _arg_ )</h1>
      <p>
        The `fromString` method takes one argument _arg_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Return ? ToDate(_arg_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _one_ be ? ToDate(_one_).
        1. Let _two_ be ? ToDate(_two_).
        1. If _one_.[[Year]] &gt; _two_.[[Year]], return 1.
        1. If _one_.[[Year]] &lt; _two_.[[Year]], return -1.
        1. If _one_.[[Month]] &gt; _two_.[[Month]], return 1.
        1. If _one_.[[Month]] &lt; _two_.[[Month]], return -1.
        1. If _one_.[[Day]] &gt; _two_.[[Day]], return 1.
        1. If _one_.[[Day]] &lt; _two_.[[Day]], return -1.
        1. Return +0.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id=sec-properties-of-the-temporal-date-prototype-object>
    <h1>Properties of the Temporal.Date Prototype Object</h1>

    <p>The Temporal.Date prototype object</p>
    <ul>
      <li>is the intrinsic object %Temporal.Date.prototype%.
      <li>is itself an ordinary object.
      <li>is not a Temporal.Date instance and does not have a [[InitializedTemporalDate]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id=sec-temporal.date.prototype.constructor>
      <h1>Temporal.Date.prototype.constructor</h1>
      <p>The initial value of Temporal.Date.prototype.constructor is %Temporal.Date%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.date.prototype-@@tostringtag">
      <h1>Temporal.Date.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value `"Temporal.Date"`.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.year</h1>
      <p>
        Temporal.Date.prototype.year is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _date_.[[Year]].
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.month</h1>
      <p>
        Temporal.Date.prototype.month is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _date_.[[Month]].
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.day</h1>
      <p>
        Temporal.Date.prototype.day is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return _date_.[[Day]].
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.dayOfWeek</h1>
      <p>
        Temporal.Date.prototype.dayOfWeek is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ToDayOfWeek(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.dayOfYear</h1>
      <p>
        Temporal.Date.prototype.dayOfYear is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ToDayOfYear(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.weekOfYear</h1>
      <p>
        Temporal.Date.prototype.weekOfYear is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ToWeekOfYear(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.daysInYear</h1>
      <p>
        Temporal.Date.prototype.daysInYear is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. If ! IsLeapYear(_date_.[[Year]]) is *true*, then
          1. Return 366.
        1. Return 365.
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.daysInMonth</h1>
      <p>
        Temporal.Date.prototype.daysInMonth is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return DaysInMonth(_date_.[[Year]], _date_.[[Month]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>get Temporal.Date.prototype.leapYear</h1>
      <p>
        Temporal.Date.prototype.leapYear is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ! IsLeapYear(_date_.[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.getYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ? CreateYearMonth(_date_.[[Year]], _date_.[[Month]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.getMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Return ? CreateMonthDay(_date_.[[Month]], _date_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.plus ( _duration_, _disambiguation_ )</h1>
      <p>
        The `plus` method takes two arguments, _duration_ and _disambiguation_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _duration_ be ? ToDurationLike(_duration_).
        1. <mark>TODO: Throw if any time properties are present?</mark>
        1. Let _disambiguation_ be ? ToString(_disambiguation_).
        1. Return ? AddDate(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Days]], _disambiguation_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.minus ( _duration_, _disambiguation_ )</h1>
      <p>
        The `minus` method takes two arguments, _duration_ and _disambiguation_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _duration_ be ? ToDurationLike(_duration_).
        1. <mark>TODO: Throw if any time properties are present?</mark>
        1. Let _disambiguation_ be ? ToString(_disambiguation_).
        1. Let _y_ be _date_.[[Year]] - _duration_.[[Years]].
        1. Let _m_ be _date_.[[Month]] - _duration_.[[Months]].
        1. Let _intermediate_ be ? RegulateDate(_y_, _m_, _date_.[[Day]], _disambiguation_).
        1. Let _d_ be _intermediate_.[[Day]] - _duration_.[[Days]].
        1. Let _result_ be ? RegulateDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_, `"balance"`).
        1. Return ? CreateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.with ( _otherDate_, _disambiguation_ )</h1>
      <p>
        The `with` method takes two arguments, _otherDate_ and _disambiguation_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _otherDate_ be ? ToPartialDate(_otherDate_).
        1. Let _disambiguation_ be ? ToString(_disambiguation_).
        1. If _otherDate_.[[Year]] is not *undefined*, then
          1. Let _y_ be _otherDate_.[[Year]].
        1. Else
          1. Let _y_ be _date_.[[Year]].
        1. If _otherDate_.[[Month]] is not *undefined*, then
          1. Let _m_ be _otherDate_.[[Month]].
        1. Else
          1. Let _m_ be _date_.[[Month]].
        1. If _otherDate_.[[Day]] is not *undefined*, then
          1. Let _d_ be _otherDate_.[[Day]].
        1. Else
          1. Let _d_ be _date_.[[Day]].
        1. Let _result_ be ? RegulateDate(_y_, _m_, _d_, _disambiguation_).
        1. Return ? CreateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.difference ( _otherDate_, _disambiguation_ )</h1>
      <p>
        The `difference` method takes two arguments, _otherDate_ and _disambiguation_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _otherDate_ be ? ToDate(_otherDate_).
        1. Let _disambiguation_ be ? ToString(_disambiguation_).
        1. Let _greater_ be _date_.
        1. Let _smaller_ be _otherDate_.
        1. <mark>TODO: Swap order if needed.</mark>
        1. Let _years_ be _greater_.[[Year]] - _smaller_.[[Year]].
        1. Let _days_ be ToDayOfYear(_greater_.[[Year]], _greater_.[[Month]], _greater_.[[Day]]) - ToDayOfYear(_smaller_.[[Year]], _smaller_.[[Month]], _smaller_.[[Day]]).
        1. If _days_ &lt; 0, then
          1. Set _years_ to _years_ - 1.
          1. Let _daysInYear_ be 366 if LeapYear(_greater_.[[Year]]) is *true* and 365 otherwise.
          1. Set _days_ to _days_ + _daysInYear_.
        1. <mark>Assert: _days_ &ge; 0.</mark>
        1. Return ? CreateDuration(_years_, 0, _days_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.withTime ( _time_ )</h1>
      <p>
        The `withTime` method takes one argument _time_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _time_ be ? ToTimeLike(_time_).
        1. If any of _time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]], _time_.[[Millisecond]], _time_.[[Microsecond]], or _time_.[[Nanosecond]] is *undefined*, then
          1. <mark>TODO: Merge into ToTimeLike?</mark>
          1. Throw a *TypeError* exception.
        1. Return ? CreateDateTime(_date_.[[Year]], _date_.[[Month]], _date_.[[Day]],
          _time_.[[Hour]], _time_.[[Minute]], _time_.[[Second]],
          _time_.[[Millisecond]], _time_.[[Microsecond]], _time_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.toString ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _year_ be PadYear(_date_.[[Year]]).
        1. Let _month_ be _date_.[[Month]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _date_.[[Day]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), and _day_.
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.toLocaleString ( …_args_ )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, _args_).
        1. Return ? FormatDateTime(_dateFormat_, _date_).
      </emu-alg>
    </emu-clause>

    <emu-clause>
      <h1>Temporal.Date.prototype.toJSON ( )</h1>
      <p><mark>TODO: Share with toString().</mark></p>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _date_ be the *this* value.
        1. If Type(_date_) is not Object or _date_ does not have an [[InitializedTemporalDate]] internal slot, then
          1. Throw a *TypeError* exception.
        1. Let _year_ be PadYear(_date_.[[Year]]).
        1. Let _month_ be _date_.[[Month]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _date_.[[Day]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), and _day_.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id=sec-properties-of-temporal-date-instances>
    <h1>Properties of Temporal.Date Instances</h1>
    <p>Temporal.Date instances are ordinary objects that inherit properties from the %Temporal.Date.prototype%.</p>
    <p>Temporal.Date instances have the following internal slots:
    <ul>
      <li>[[Year]], representing the year.</li>
      <li>[[Month]], representing the month within the year. It lies between 1 and 12, inclusive.</li>
      <li>[[Day]], representing the day within the month. It lies between 1 and DaysInMonth([[Year]], [[Month]]), inclusive.</li>
    </ul>
    <p>The value of each of these internal slots is a Number which is an integer.</p>
  </emu-clause>

  <emu-clause id=sec-temporal-date-abstract-ops>
    <h1>Abstract operations</h1>

    <emu-clause id=sec-temporal-date-create aoid=CreateDate>
      <h1>CreateDate ( _y_, _m_, _d_ [ , _newTarget_ ] )</h1>
      <emu-alg>
        1. Assert: ! ValidateDate(_y_, _m_, _d_) is *true*.
        1. If _newTarget_ is not given, set it to %Temporal.Date%
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%Temporal.Date.prototype%"`, « [[InitializedTemporalDate]], [[Year]], [[Month]], [[Day]] »).
        1. Set _object_.[[Year]] to _y_.
        1. Set _object_.[[Month]] to _m_.
        1. Set _object_.[[Day]] to _d_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-temporal-DateFromString aoid=DateFromString>
      <h1>DateFromString ( _date_ )</h1>
      <emu-alg>
        1. Assert: Type(_date_) is String.
        1. Let _validSyntax_ be *true* if _isostring_ conforms to the format `YYYY-MM-DD`, and *false* otherwise, where:
          * `YYYY` is either four decimal digits or an expanded year of `"+"` or `"-"` followed by six decimal digits;
          * `-` is the code unit 0x002D (HYPHEN-MINUS);
          * `MM` is two decimal digits;
          * `-` is the code unit 0x002D (HYPHEN-MINUS);
          * `DD` is two decimal digits.
        1. If _validSyntax_ is *false*, then
          1. Throw a *RangeError* exception.
        1. Let _year_, _month_, and _day_ be the respective parts of _isostring_, interpreted as decimal numbers.
        1. Let _result_ be ? RegulateDate(_year_, _month_, _day_, `"reject"`).
        1. Return ? CreateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-temporal-ToDate aoid=ToDate>
      <h1>ToDate ( _date_ )</h1>
      <emu-alg>
        1. If Type(_date_) is String, then
          1. Return ? DateFromString(_date_).
        1. If Type(_date_) is Object, then
          1. Let _result_ be the Record {
            [[Year]]: *undefined*,
            [[Month]]: *undefined*,
            [[Day]]: *undefined*,
            }.
          1. If _date_ has an [[InitializedTemporalDate]] internal slot, then
            1. Return _date_.
          1. For each row of <emu-xref href="#table-temporal-datelike-properties"></emu-xref>, except the header row, in table order, do
            1. Let _property_ be the Property value of the current row.
            1. Let _value_ be ? Get(_date_, _property_).
            1. If _value_ is *undefined*, then
              1. Throw a *TypeError* exception.
            1. Let _value_ be ? ToInteger(_value_).
            1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
          1. If ! ValidateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]]) is *false*, then
            1. Throw a *TypeError* exception.
          1. Return ? CreateDate(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]).
        1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-temporal-ToPartialDate aoid=ToPartialDate>
      <h1>ToPartialDate ( _date_ )</h1>
      <emu-alg>
        1. Let _result_ be {
          [[Year]]: *undefined*,
          [[Month]]: *undefined*,
          [[Day]]: *undefined*,
          }.
        1. If Type(_date_) is Undefined or Null, then
          1. Return _result_.
        1. <mark>TODO: Handle strings?</mark>
        1. If Type(_date_) is not Object, then
          1. Throw a *TypeError* exception.
        1. For each row of <emu-xref href="#table-temporal-datelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? ToInteger(? Get(_date_, _property_)).
          1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. Return _result_.
      </emu-alg>

      <emu-table id="table-temporal-datelike-properties">
        <emu-caption>Properties of a DateLike</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[[Day]]</td>
              <td>`"day"`</td>
            </tr>
            <tr>
              <td>[[Month]]</td>
              <td>`"month"`</td>
            </tr>
            <tr>
              <td>[[Year]]</td>
              <td>`"year"`</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id=sec-temporal-RegulateDate aoid=RegulateDate>
      <h1>RegulateDate ( _y_, _m_, _d_, _disambiguation_ )</h1>
      <emu-alg>
        1. If _disambiguation_ is *"reject"*, then
          1. Perform ? RejectDate(_year_, _month_, _day_).
        1. Else if _disambiguation_ is *"constrain"*, then
          1. Let _result_ be ? ConstrainDate(_year_, _month_, _day_).
          1. Set _y_ to _result_.year.
          1. Set _m_ to _result_.month.
          1. Set _d_ to _result_.day.
        1. Else if _disambiguation_ is *"balance"*, then
          1. Let _result_ be ? BalanceDate(_year_, _month_, _day_).
          1. Set _y_ to _result_.year.
          1. Set _m_ to _result_.month.
          1. Set _d_ to _result_.day.
        1. Else,
          1. Throw a *TypeError* exception.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-temporal-ValidateDate aoid=ValidateDate>
      <h1>ValidateDate ( _y_, _m_, _d_ )</h1>
      <emu-alg>
        1. Assert: _y_, _m_, and _d_ are integer Number values.
        1. If _m_ &lt; 1 or _m_ &gt; 12, then
          1. Return *false*.
        1. Let _maxDay_ be DaysInMonth(_y_, _m_).
        1. If _d_ &lt; 1 or _d_ &gt; _maxDay_, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-temporal-PadYear aoid=PadYear>
      <h1>PadYear ( _y_ )</h1>
      <emu-alg>
        1. Assert: _y_ is an integer Number value.
        1. If _y_ &gt; 999 and _y_ &le; 9999, then
          1. Return _y_ formatted as a four-digit decimal number, padded to the left with a zero if necessary.
        1. If _y_ &ge; 0, let _yearSign_ be `"+"`; otherwise, let _yearSign_ be `"-"`.
        1. Let _year_ be abs(_y_), formatted as a decimal number.
        1. Return the string-concatenation of _yearSign_ and _year_.
      </emu-alg>
    </emu-clause>

    <emu-clause id=sec-temporal-AddDate aoid=AddDate>
      <h1>AddDate ( _year_, _month_, _day_, _years_, _months_, _days_, _disambiguation_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _years_, _months_, and _days_ are integer Number values.
        1. Assert: _disambiguation_ is one of `"constrain"`, `"balance"`, or `"reject"`.
        1. Let _y_ be _year_ + _years_.
        1. Let _m_ be _month_ + _months_.
        1. Let _intermediate_ be ! BalanceYearMonth(_y_, _m_).
        1. Let _intermediate_ be ? RegulateDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _day_, _disambiguation_).
        1. Let _d_ be _intermediate_.[[Day]] + _days_.
        1. Return ! BalanceDate(_intermediate_.[[Year]], _intermediate_.[[Month]], _d_).
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
